PR include "read.a68" PR

PROC traverse = (REF NUMBER num, PROC(INT,REF NUMBER)BOOL visit)VOID:
BEGIN
  PROC dive into = (INT depth, REF NUMBER num)VOID:
  BEGIN
    BOOL found = visit(depth, num);
    CASE num IN
      (REF PAIR sub): IF NOT found THEN
                        dive into(depth+1, left  OF sub);
			dive into(depth+1, right OF sub)
                      FI
    ESAC
  END;
  dive into(0,num)
END;

PRIO COPY = 1;
OP COPY = (NUMBER x)NUMBER:
  CASE x IN
    (REF PAIR pair): make pair(COPY left OF pair, COPY right OF pair)
  OUT x
  ESAC;

PROC snailfish reduce = (NUMBER n)NUMBER:
BEGIN
  NUMBER data := COPY n;
  REF NUMBER last regular;
  INT add to next regular;
  BOOL exploded;

  PROC explode = (INT depth, REF NUMBER cell)BOOL:
    CASE cell IN (REF PAIR pair): 
                  IF depth >= 4 AND NOT exploded THEN
                    IF REF NUMBER prev cell = last regular; prev cell ISNT NIL THEN
                      prev cell := (prev cell | (INT n): n) + (left OF pair | (INT n): n)
                    FI;
                    add to next regular := (right OF pair | (INT n): n);
                    cell := 0;
                    exploded := TRUE
                  ELSE FALSE
                  FI,
                  (INT n): 
                    BEGIN
                      cell := n + add to next regular;
                      last regular := cell;
                      IF exploded THEN just start again FI
                    END
    ESAC;

  PROC split = (INT depth, REF NUMBER cell)BOOL:
    (cell | (INT n): IF n >= 10 THEN cell := make pair (n%2, (n+1)%2); just start again FI | FALSE);
   
just start again:
  CO dump(data); print(new line); CO
  exploded := FALSE;
  last regular := NIL;
  add to next regular := 0;
  traverse(data, explode);
  traverse(data, split);
  data
END;

CO note: because "INT" is directly convertible into a number, we can't overload "OP +" easily CO
PROC add = (NUMBER x,y)NUMBER:
  snailfish reduce(LOC PAIR:=(x,y));

OP ABS = (NUMBER x)INT:
  CASE x IN
    (INT n): n,
    (REF PAIR pair): 3*ABS left OF pair + 2*ABS right OF pair
  ESAC;

INT max magnitude := -1000;
NUMBER x1, x2;

FOR i TO UPB homework DO FOR j TO UPB homework DO
  IF i /= j THEN
    INT this = ABS add(homework[i], homework[j]);
    (this > max magnitude | max magnitude := this;
      x1 := homework[i];
      x2 := homework[j])
  FI
OD OD;

dump(x1); print(new line);
dump(x2); print(new line);
print((max magnitude, new line))
